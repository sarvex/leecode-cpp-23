### 862.Shortest-Subarray-with-Sum-at-Least-K

#### 解法１
遇到continous subarray的题目,最常用的策略就是构建累加和preSum数组.这样,此题就转化为在preSum中找到两个间距最短的位置j和i,使得```preSum[j]-preSum[i]>=K```.对于这种题,通常我们会遍历i,然后在每个i之前的index查找满足条件的最小j.

对于此类问题,我们会把所有经历过的preSum都存在一个有序集合里.这里我们使用map,记录曾经出现过的preSum以及它对应的在数组中的index.注意到如果遇到相同的preSum,后加入的index会覆盖先前的值,这是合理的:因为对于任何preSum我们恰需要更新的,较大的index来保持[j,i]之间的距离最短.

假设我们考虑某个i,那么在i之前出现的所有preSum都已经在map里.此时如果map里所有键小于```preSum[i]-K```的preSum都是符合要求的.我们只要遍历这些键对应的值(也就是index),找到最大的那个就是距离i最近的j.

这样的算法仍然会超时,主要是因为上面遍历键值的过程花时间.怎么优化呢?

我们每次在将```{preSum[i],i}```插入map时,插入的可能是map中间的某个位置.我们发现,此时所有大于preSum[i]的键都是没有意义的,因为你preSum[i]带来了当前最新(也是最大)的值i.举个例子,如果此时目标键为k且k>preSum[i],那么在map中搜索所有小于等于k的"键"并且找它们之中最大的"值",得到的结果必然是i.所以每个回合里,我们插入```{preSum[i],i}```之后,可以将map从后往前不断删除元素,直至遇到preSum[i]为止,这样可以使得map始终保持精简.

上面这个操作会带来一个意想不到的好处!那就是我们不需要找在map里遍历所有小于等于```preSum[i]-K```的所有键并求最大的值．因为这些"键"对应的最大"值"就存在于离```preSum[i]-K```最近的那个键里面．更本质的原因是，map里不仅键是递增的，而且对应的值也是递增的．

所以每个回合的过程可以总结为:
```
1.在map里找到小于并且离preSum[i]-K最近的那个键,其值就是所需的满足条件的最大j
2.在map里插入{preSum[i],i}
3.在map删除所有大于preSum[i]的键
```

#### 解法2：单调队列
上述的解法复杂度是o(NlogN),但实际上还有更好的o(N)的解法．我们基于nums的前缀和数组presum，维护一个双端队列q，保持队列里面的元素是递增的。我们每处理一个新的presum[i]，希望在队列里查看最近的j，使得`presum[i]-presum[j]>=k`. 显然我们希望j的位置尽量靠后，同时presum[j]的数值尽量小。

我们假想，presum的前若干个元素本身就是递增的，那么我们就可以照单全收都放入deque里面。此时如果新元素presum[i]比队尾元素（记做j）要小，那么我们就可以把队尾元素j去掉。这是因为从此以后，presum[j]都不会是最优解所对应的区间左端点。考察上面式子的被减数，这个presum[j]相比于presum[i]而言既“老”又“大”，选j永远不如选i。

同时针对新加入的presum[i]，我们考察队首元素（也记做j），观察是否满足`presum[i]-presum[j]>=k`。如果是的话，显然`[j+1,i]`就是一个合法的解。注意，此时我们就可以将j弹出了。因为我们不需要j再与其他位置（指i之后的）匹配合法的区间了，因为即使存在，那样的区间长度也会更长。

所以每次处理一个presum[i]时，遵循上述两个步骤，保证队列存储的是一个presum的递增序列，就能够方便的求出相对于i的区间左端点（如果存在的话，就是队首元素）。


[Leetcode Link](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k)
