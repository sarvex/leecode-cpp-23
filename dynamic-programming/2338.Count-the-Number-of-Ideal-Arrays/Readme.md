### 2338.Count-the-Number-of-Ideal-Arrays

我们令序列的最后一个元素是x，那么这个长度为n的序列的本质就是从1开始，每次乘以1或者一个x的非1的因数，直至最后一个元素变成x。显然，这些非1的因数的集合必须是x的一个分解，比如说，当n=4, x=30的时候，可以有```30 = 1*2*3*5```，对应的序列就是{1,2,6,30}；或者```30 = 5*1*3*2```，对应的序列就是{5,5,15,30}，以及其他。

考虑到x的普通因数分解其实太多了，但是质因数分解是唯一的，比如记做```x = a*b*c...```。所以我们很容易发现，我们本质只需要将每个质因数任意地分配这n个位置上，最后都能对应一个符合条件的序列。特别注意，每个位置可以允许放置多个质因数。比如上面的例子，将30的质因数分解```2*3*5```任意丢进4个位置上：我们可以```(),(2),(5),(3)```，那么本质上就对应了序列{1,2,10,30}；我们也可以```(),(2,3),(5),()```，那么本质上就对应了序列{1,6,30,30}。

既然每个质因数都可以独立放置，那么假设x总共有k个质因数，那么以x为结尾的序列个数是不是就是```n^k```呢？我们这里发现了一个问题，那就是没法保证这些序列是distinct的，问题出在相同的质因数上。比如说n=2,x=4的例子，x有两个相同的质因数（记做2a和2b），如果各自独立地扔进两个位置，那么我们会有四种分配方式 ```{a1, a2}, {a2, a1}, {_ , a1*a2}, {a1*a2, _}```. 但是前两者序列都对应了{2,4}这一样的序列。

至此，我们调整目标，当前需要解决的问题是：对于k个相同的质因数，我们想将它们分配在n个位置上（允许一个位置有多个），那么有多少种看上去“不同”的分配方式。这应该就是一个典型的DP题。我们类似地定义dp[i][j]，那么转移方程的关键就是看第i个位置上我们放置了多少个质因数，假设如果有t个，那么问题就转移到了dp[i-1][j-t]。所以大致的dp方程就是
```cp
for (int i=1; i<=n; i++)
  for (int j=0; j<=k; j++)
  {
      for (int t=0; t<=j; t++)
        dp[i][j] += dp[i-1][j-t];
  }
```
预处理全部dp值的时间复杂度是o(NKK)，其中K是对于x的某个质因数的个数。考虑到x的上限是10000，就算这个质因数是最小的2，那么重复出现的次数也不会超过14，否则2^14就超过了上限。所以dp的时间复杂度就是o(196N)，考虑到N是1e4，那么恰好完美符合题目的预期。

综上，本题的解法是：从1到MaxVal遍历x作为序列的最后一个元素：对x做质因数分解，对于每种质因数，如果个数是k，我们就有dp[n][k]种分配方法，然后将所有不同质因数的分配方法相乘。最后把不同的x的结果再相加。

