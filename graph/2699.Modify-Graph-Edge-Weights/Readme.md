### 2699.Modify-Graph-Edge-Weights

因为最终修正边权之后的图里要求所有的边都是正数，所以我们第一步肯定先将所有能修改的边从-1改为为最小的正数值1放入图中。

最暴力的思想就是不停地跑Dijkstra求起点到终点的最短距离。如果当前的最短距离已经大于target，那么无解。如果当前的最短距离就是target，那么我们就不需要改动。如果当前的最短距离小于target，且最短距离里不包括任何可修改的边，那么也是无解。剩下的情况就是最短距离小于target，且其中包含了至少一条可修改的边，那么我们可以贪心地将该边权调大，使得路径恰为target。这样我们就消灭了一条小于target的路径。然后重复以上的过程。这样的算法可能会跑o(E)遍的Dijkstra，会TLE。

我们再审视一下我们的Dijkstra算法。注意当我们每次从PQ里弹出一个已经确定最短距离的的点，会尝试通过其邻接的边将一个新点加入PQ，如果我们所用到的所有的边都是不可修改的，那么我们弹出的点及其最短路径也都是不可修改的。但是当我们需要用到一条可修改的边时，比如说已知从起点到a的最短路径，然后a与b有一条可修改的边，此时我们在将b加入PQ时就会有所顾虑。如果“起点到a的最短距离”+“ab之间的边权1”+“b到终点的最短距离”小于target的话，那么我们就违反了题意。所以我们可以贪心地更改这条可修改边，使得三段距离之和变成target。这就意味着我们需要提前计算“b到终点的最短距离”。这样，当b收录进入PQ的时候，我们就保证了这条到达b的路径，不会造成任何“起点到终点的最短路径小于target”，我们可以放心地加入PQ共后续使用。

所以依据上面的算法，可以在一次的Dijkstra的过程中不断地贪心地设置可修改边的边权。知道我们发现终点从PQ里弹出时，意味着我们已经确定了起点到终点的最短距离。如果这个距离不为target，那么就是无解。
